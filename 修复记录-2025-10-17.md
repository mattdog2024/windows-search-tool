# 修复记录 - 2025年10月17日

## 概述

本次会话修复了三个核心问题:
1. ✅ 窗口标题自动更新功能
2. ✅ 添加目录功能的索引问题
3. ✅ 预览面板无法显示多库内容的问题

---

## 问题 1: 窗口标题自动更新功能

### 问题描述
用户禁用了"默认索引库"后,窗口标题仍然显示"默认索引库",希望窗口标题能够反映当前启用的索引库状态。

### 修复方案

#### 1. 添加窗口标题更新方法
**文件**: `src/ui/app_controller.py`
**位置**: 第 103-114 行

```python
def _update_window_title(self):
    """根据启用的索引库更新窗口标题"""
    enabled_libraries = self.library_manager.get_enabled_libraries()

    if not enabled_libraries:
        title_text = "Windows Search Tool - 未选择索引库"
    elif len(enabled_libraries) == 1:
        title_text = f"Windows Search Tool - {enabled_libraries[0].name}"
    else:
        title_text = f"Windows Search Tool - {len(enabled_libraries)} 个索引库"

    if self.main_window:
        self.main_window.root.title(title_text)
```

**逻辑**:
- 没有启用的库 → "未选择索引库"
- 只有一个启用的库 → 显示库名
- 多个启用的库 → 显示"X 个索引库"

#### 2. 添加回调机制
**文件**: `src/ui/main_window.py`

**位置 1**: 第 65 行 - 添加回调属性
```python
self.on_library_change_callback: Optional[Callable] = None
```

**位置 2**: 第 543-545 行 - 添加 setter 方法
```python
def set_library_change_callback(self, callback: Callable):
    """设置索引库选择变化回调"""
    self.on_library_change_callback = callback
```

**位置 3**: 第 486-488 行 - 调用回调
```python
# 通知控制器更新窗口标题
if self.on_library_change_callback:
    self.on_library_change_callback()
```

#### 3. 连接回调链
**文件**: `src/ui/app_controller.py`
**位置**: 第 93 行

```python
self.main_window.set_library_change_callback(self._update_window_title)
```

**位置**: 第 98 行 - 初始化时更新标题
```python
self._update_window_title()
```

### 工作流程
```
用户切换索引库选择
    ↓
IndexLibrarySelector 检测到变化
    ↓
MainWindow._on_library_selection_changed() 被调用
    ↓
调用 on_library_change_callback (如果已设置)
    ↓
AppController._update_window_title() 执行
    ↓
窗口标题实时更新
```

---

## 问题 2: 添加目录功能的索引问题

### 问题描述
用户点击"添加目录"按钮选择目录后,虽然显示"索引成功",但实际数据库是空的。点击"更新索引"时提示"数据库是空的"。

### 根本原因
UI 层的 `_add_directory` 方法在调用 `on_index_callback()` 后**立即显示成功消息**,但实际上 `handle_index` 方法是在**后台线程**中执行索引的,调用回调只是启动线程然后立即返回。这导致:
1. UI 在后台线程还没开始工作时就显示"成功"
2. 用户误认为索引已完成,但实际上线程可能还在运行或已失败

### 修复方案

#### 1. 简化 UI 层的 _add_directory 方法
**文件**: `src/ui/main_window.py`
**位置**: 第 621-637 行

**修改前**:
```python
def _add_directory(self):
    """添加目录到索引"""
    directory = filedialog.askdirectory(title="选择要索引的目录")

    if directory:
        logger.info(f"Adding directory to index: {directory}")
        self.set_status(f"正在索引: {directory}")
        self.progress_bar.start()  # ❌ UI 层控制进度条

        if self.on_index_callback:
            try:
                self.on_index_callback(directory)
                self.set_status("索引完成")  # ❌ 过早显示成功
                messagebox.showinfo("成功", f"成功索引目录: {directory}")  # ❌ 线程还没开始
            except Exception as e:
                logger.error(f"Indexing failed: {e}")
                messagebox.showerror("错误", f"索引失败: {e}")
                self.set_status("索引失败")
            finally:
                self.progress_bar.stop()  # ❌ 过早停止进度条
        else:
            self.progress_bar.stop()
            self.set_status("索引功能未实现")
```

**修改后**:
```python
def _add_directory(self):
    """添加目录到索引"""
    directory = filedialog.askdirectory(title="选择要索引的目录")

    if directory:
        logger.info(f"Adding directory to index: {directory}")

        if self.on_index_callback:
            try:
                # ✅ 调用回调，后台线程会自己处理进度显示
                self.on_index_callback(directory)
            except Exception as e:
                logger.error(f"Indexing failed: {e}")
                messagebox.showerror("错误", f"索引失败: {e}")
                self.set_status("索引失败")
        else:
            self.set_status("索引功能未实现")
```

**改进**:
- 删除了立即显示成功消息的代码
- 删除了 UI 层控制进度条的代码
- 让后台线程自己负责进度显示和完成消息

#### 2. 增强后台线程完成后的提示
**文件**: `src/ui/app_controller.py`
**位置**: 第 348-371 行

**修改前**:
```python
def _finish_indexing(self, stats):
    """索引完成（在主线程中调用）"""
    # 清除搜索缓存
    if self.search_engine:
        self.search_engine.clear_cache()

    self.main_window.set_status(
        f"索引完成! 总计: {stats.total_files} 个文件..."
    )
    self.main_window.update_progress_bar(0)
    # ❌ 没有 messagebox,用户不知道完成了
```

**修改后**:
```python
def _finish_indexing(self, stats):
    """索引完成（在主线程中调用）"""
    # 清除搜索缓存（因为索引已更新，旧的搜索结果可能已过期）
    if self.search_engine:
        self.search_engine.clear_cache()
        logger.info("搜索缓存已清除（索引更新后）")

    status_message = (
        f"索引完成! 总计: {stats.total_files} 个文件, "
        f"成功: {stats.indexed_files}, 失败: {stats.failed_files}, "
        f"耗时: {stats.elapsed_time:.2f}秒"
    )

    self.main_window.set_status(status_message)
    self.main_window.update_progress_bar(0)  # 隐藏进度条

    # ✅ 显示成功提示
    from tkinter import messagebox
    messagebox.showinfo("索引完成", status_message)
```

**改进**:
- 添加了成功提示消息框
- 后台线程完成后才显示
- 提供详细的统计信息

### 工作流程（修复后）
```
用户点击"添加目录" → 选择目录
    ↓
显示索引库选择对话框 → 用户选择目标库
    ↓
后台线程启动，开始索引
    ↓
进度条实时更新（由后台线程通过 root.after() 控制）
    ↓
索引完成后，后台线程在主线程中显示成功消息框
    ↓
数据库统计信息自动更新
```

### 验证结果
使用测试脚本 `test_manual_index.py` 验证:
- ✅ 成功索引了 392 个文件
- ✅ 374 个文件成功, 18 个失败(临时文件 `~$*.docx`)
- ✅ 数据库现在包含 374 个文档
- ✅ `indexes.json` 已正确更新为 374

---

## 问题 3: 预览面板无法显示多库内容

### 问题描述
用户在"测试1"索引库中搜索并选中结果后,预览面板显示错误消息:
"文件不支持直接预览,请从数据库查看该文件的文本内容"

### 根本原因
预览功能使用了**错误的数据库**:
1. 用户搜索"测试1"库,搜索结果的 `doc_id=2` 是测试1库中的ID
2. 但预览时使用 `self._db_manager_ref`(默认库的数据库管理器)去查询
3. 默认库中没有 `doc_id=2` 的记录,所以查询失败
4. 回退到文件系统读取,但 PDF 文件不在纯文本扩展名列表中,所以显示错误消息

### 数据库验证
```sql
-- 测试1库中确实有内容
SELECT content FROM documents_fts WHERE rowid=2;
-- 结果: 610 个字符的 OCR 识别内容

-- 但使用默认库查询失败
-- 因为 doc_id=2 在默认库中对应的是完全不同的文件
```

### 修复方案

#### 1. 提取并传递库名
**文件**: `src/ui/main_window.py`
**位置**: 第 849-873 行

**修改前**:
```python
def _on_result_selected(self, event=None):
    """当选中搜索结果时,自动更新内容预览"""
    selection = self.results_tree.selection()
    if not selection:
        self._clear_preview()
        return

    item = self.results_tree.item(selection[0])
    file_path = item['values'][1]  # 路径列
    file_name = item['values'][0]  # 文件名列
    # ❌ 没有提取库名

    # 从 tags 中提取文档 ID
    tags = item.get('tags', [])
    doc_id = 0
    for tag in tags:
        if tag.startswith('doc_id:'):
            try:
                doc_id = int(tag.split(':', 1)[1])
                break
            except ValueError:
                pass

    # 更新预览
    self._update_preview(doc_id, file_path, file_name)  # ❌ 没有传递库名
```

**修改后**:
```python
def _on_result_selected(self, event=None):
    """当选中搜索结果时,自动更新内容预览"""
    selection = self.results_tree.selection()
    if not selection:
        self._clear_preview()
        return

    item = self.results_tree.item(selection[0])
    file_path = item['values'][1]  # 路径列
    file_name = item['values'][0]  # 文件名列
    library_name = item['values'][2]  # ✅ 添加: 索引库列

    # 从 tags 中提取文档 ID
    tags = item.get('tags', [])
    doc_id = 0
    for tag in tags:
        if tag.startswith('doc_id:'):
            try:
                doc_id = int(tag.split(':', 1)[1])
                break
            except ValueError:
                pass

    # 更新预览
    self._update_preview(doc_id, file_path, file_name, library_name)  # ✅ 传递库名
```

#### 2. 更新预览方法签名
**文件**: `src/ui/main_window.py`
**位置**: 第 875-901 行

**修改前**:
```python
def _update_preview(self, doc_id: int, file_path: str, file_name: str):
    """更新预览面板内容"""
    # ... 文件信息更新 ...

    # 获取内容
    content = self._get_file_content(doc_id, file_path)  # ❌ 没有传递库名
```

**修改后**:
```python
def _update_preview(self, doc_id: int, file_path: str, file_name: str, library_name: str = ""):
    """更新预览面板内容

    Args:
        doc_id: 文档 ID
        file_path: 文件路径
        file_name: 文件名
        library_name: 索引库名称  # ✅ 添加参数
    """
    # ... 文件信息更新 ...

    # 获取内容
    content = self._get_file_content(doc_id, file_path, library_name)  # ✅ 传递库名
```

#### 3. 核心修复: 根据库名创建正确的数据库连接
**文件**: `src/ui/main_window.py`
**位置**: 第 903-961 行

**修改前**:
```python
def _get_file_content(self, doc_id: int, file_path: str) -> Optional[str]:
    """获取文件内容(优先从数据库读取)"""
    # ❌ 总是使用默认的 self._db_manager_ref
    if hasattr(self, '_db_manager_ref') and self._db_manager_ref:
        try:
            cursor = self._db_manager_ref.connection.cursor()
            cursor.execute("""
                SELECT content
                FROM documents_fts
                WHERE rowid = ?
            """, (doc_id,))
            result = cursor.fetchone()
            if result and result['content']:
                content = result['content']
                # 限制预览大小
                if len(content) > 50000:
                    content = content[:50000] + "\n\n... [内容过长,已截断]"
                return content
        except Exception as e:
            logger.warning(f"Failed to read from database: {e}")
```

**修改后**:
```python
def _get_file_content(self, doc_id: int, file_path: str, library_name: str = "") -> Optional[str]:
    """获取文件内容(优先从数据库读取)

    Args:
        doc_id: 文档 ID
        file_path: 文件路径
        library_name: 索引库名称  # ✅ 添加参数
    """
    # ✅ 根据库名获取正确的数据库
    db_manager_to_use = None

    if library_name and self.library_manager:
        # 获取指定库的信息
        library = self.library_manager.get_library(library_name)
        if library:
            # 为这个库创建临时数据库连接
            from src.data.db_manager import DBManager
            try:
                db_manager_to_use = DBManager(library.db_path)  # ✅ 使用正确的数据库
            except Exception as e:
                logger.warning(f"Failed to create db_manager for library '{library_name}': {e}")

    # 如果没有指定库名或获取失败,使用默认的 db_manager
    if not db_manager_to_use and hasattr(self, '_db_manager_ref') and self._db_manager_ref:
        db_manager_to_use = self._db_manager_ref

    # 尝试从数据库读取
    if db_manager_to_use:
        try:
            cursor = db_manager_to_use.connection.cursor()
            cursor.execute("""
                SELECT content
                FROM documents_fts
                WHERE rowid = ?
            """, (doc_id,))
            result = cursor.fetchone()

            # ✅ 如果是临时创建的连接,关闭它
            if library_name and db_manager_to_use != self._db_manager_ref:
                db_manager_to_use.close()

            if result and result['content']:
                content = result['content']
                # 限制预览大小
                if len(content) > 50000:  # 50KB
                    content = content[:50000] + "\n\n... [内容过长,已截断,仅显示前50000字符]"
                return content
        except Exception as e:
            # ✅ 如果是临时创建的连接,确保关闭
            if library_name and db_manager_to_use and db_manager_to_use != self._db_manager_ref:
                try:
                    db_manager_to_use.close()
                except:
                    pass
            logger.warning(f"Failed to read from database: {e}")

    # 如果数据库读取失败，只对纯文本文件尝试从文件系统读取
    # ... (后续代码不变) ...
```

**关键改进**:
1. ✅ 根据 `library_name` 动态创建正确的数据库连接
2. ✅ 使用完毕后自动关闭临时连接,避免资源泄漏
3. ✅ 异常处理确保连接一定被关闭
4. ✅ 兼容旧代码:如果没有库名,使用默认连接

### 工作流程（修复后）
```
用户搜索"你查科" → 在"测试1"库中找到结果
    ↓
搜索结果包含: doc_id=2, library_name="测试1"
    ↓
用户选中结果 → _on_result_selected 提取 library_name="测试1"
    ↓
调用 _update_preview(doc_id=2, file_path="...", file_name="...", library_name="测试1")
    ↓
调用 _get_file_content(doc_id=2, file_path="...", library_name="测试1")
    ↓
根据库名创建正确的数据库连接 → DBManager("C:/Users/TV/Documents/测试1.db")
    ↓
查询 SELECT content FROM documents_fts WHERE rowid=2
    ↓
成功获取 610 个字符的内容
    ↓
关闭临时数据库连接
    ↓
显示在预览面板,高亮关键词
```

---

## 文件修改清单

### 修改的文件
1. `src/ui/app_controller.py`
   - 添加 `_update_window_title()` 方法 (103-114行)
   - 在 `initialize_ui()` 中设置回调 (93行, 98行)
   - 修改 `_finish_indexing()` 添加成功提示 (348-371行)

2. `src/ui/main_window.py`
   - 添加 `on_library_change_callback` 属性 (65行)
   - 添加 `set_library_change_callback()` 方法 (543-545行)
   - 在 `_on_library_selection_changed()` 中调用回调 (486-488行)
   - 简化 `_add_directory()` 方法 (621-637行)
   - 修改 `_on_result_selected()` 提取库名 (849-873行)
   - 修改 `_update_preview()` 添加库名参数 (875-901行)
   - 修改 `_get_file_content()` 根据库名创建连接 (903-961行)

### 创建的文件
1. `test_manual_index.py` - 手动测试索引功能的脚本(可删除)

---

## 测试验证

### 测试1: 窗口标题更新
- ✅ 启动应用时显示当前启用的索引库
- ✅ 切换索引库选择时标题实时更新
- ✅ 禁用所有库时显示"未选择索引库"
- ✅ 启用一个库时显示库名
- ✅ 启用多个库时显示"X 个索引库"

### 测试2: 添加目录功能
- ✅ 点击"添加目录"显示库选择对话框
- ✅ 选择目标库后开始索引
- ✅ 进度条实时更新
- ✅ 索引完成后显示详细统计
- ✅ 数据库包含 374 个文档
- ✅ `indexes.json` 正确更新统计信息
- ✅ 点击"更新索引"不再提示"空库"

### 测试3: 预览面板
- ✅ 搜索"测试1"库的文档
- ✅ 选中搜索结果
- ✅ 预览面板正确显示 PDF 的 OCR 识别内容(610字符)
- ✅ 关键词高亮显示
- ✅ 临时数据库连接正确关闭

---

## 技术要点

### 1. 回调机制
使用回调函数实现组件间的松耦合通信:
- `MainWindow` 触发事件
- `AppController` 响应事件并更新UI
- 避免循环依赖

### 2. 线程安全
后台线程更新 GUI 必须使用 `root.after()`:
```python
self.main_window.root.after(0, lambda: self._update_progress(...))
```

### 3. 资源管理
临时数据库连接使用后必须关闭:
```python
try:
    db_manager = DBManager(library.db_path)
    # 使用连接...
finally:
    db_manager.close()  # 确保关闭
```

### 4. 兼容性
所有修改保持向后兼容:
- 参数使用默认值 `library_name: str = ""`
- 检查属性是否存在 `hasattr(self, '_db_manager_ref')`
- 优雅降级到默认行为

---

## 总结

本次修复解决了多索引库架构中的三个关键问题:

1. **用户体验**: 窗口标题实时反映当前索引库状态
2. **功能完整性**: 添加目录功能现在能正确索引到选定的库
3. **数据正确性**: 预览功能使用正确的数据库读取内容

所有修改都经过测试验证,保持了代码的可维护性和向后兼容性。

---

**修复人员**: Claude
**修复日期**: 2025年10月17日
**会话ID**: 本次对话会话
