---
name: Tesseract OCR 集成
status: open
created: 2025-10-16T08:21:20Z
updated: 2025-10-16T08:21:20Z
github: https://github.com/mattdog2024/windows-search-tool/issues/9
depends_on: [002]
parallel: true
conflicts_with: []
---

# Task: Tesseract OCR 集成

## Description

为扫描型 PDF 和图像文件实现 OCR (光学字符识别) 功能,支持中英文混合文本识别。集成 Tesseract OCR 引擎,实现图像预处理、文本识别、置信度过滤等功能,提升扫描文档的搜索能力。

**核心目标:**
- 实现 PDF 类型自动检测(文本型 vs 扫描型)
- 集成 pytesseract 进行 OCR 文本识别
- 实现图像预处理管道(灰度化、二值化、去噪、对比度增强)
- 配置中英文语言包(chi_sim + eng)
- 实现 OCR 置信度过滤机制
- 优化 OCR 性能和准确率

## Acceptance Criteria

- [ ] PDF 类型检测
  - 实现智能 PDF 类型检测算法
  - 检测指标:文本密度、页面图像占比
  - 混合型 PDF 处理策略(文本提取 + OCR)
  - 检测结果缓存机制

- [ ] Tesseract OCR 集成
  - **OCRService 类实现**
    - 初始化 Tesseract 配置
    - 语言包检测和加载(chi_sim + eng)
    - OCR 参数配置(PSM、OEM 模式)
    - 单页和多页 OCR 处理

  - **图像预处理管道**
    - 灰度化转换(RGB to Grayscale)
    - 对比度增强(CLAHE 算法)
    - 二值化处理(自适应阈值)
    - 去噪处理(高斯模糊、形态学操作)
    - 倾斜校正(可选)

- [ ] OCR 增强功能
  - 置信度计算和过滤(最低阈值 60%)
  - 多语言混合识别(中英文)
  - 分块识别(大图片分块处理)
  - OCR 结果后处理(去除乱码、修复常见错误)

- [ ] PDF OCR 集成
  - 扩展 PdfParser 支持 OCR
  - PDF 转图像(pdf2image)
  - 逐页 OCR 处理
  - 文本型和扫描型混合处理
  - OCR 进度跟踪

- [ ] 性能优化
  - OCR 结果缓存(避免重复识别)
  - 多线程/多进程 OCR(可选)
  - 内存优化(大文件分批处理)
  - 超时保护(单页最多 60 秒)

- [ ] 错误处理和日志
  - Tesseract 未安装检测
  - 语言包缺失提示
  - OCR 失败降级策略
  - 详细的 OCR 日志(识别率、耗时等)

- [ ] 单元测试
  - PDF 类型检测测试
  - 图像预处理效果测试
  - OCR 准确率测试(使用标准测试图片)
  - 中英文混合识别测试
  - 性能测试(大文件处理)
  - 代码覆盖率 ≥ 85%

## Technical Details

### OCR 服务类

```python
# src/services/ocr_service.py
import pytesseract
from PIL import Image, ImageEnhance, ImageFilter
import numpy as np
import cv2
import logging
import time
from typing import Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class OCRResult:
    """OCR 识别结果"""
    text: str
    confidence: float
    language: str
    processing_time: float
    success: bool
    error: Optional[str] = None

class OCRService:
    """OCR 服务类"""

    def __init__(self, tesseract_path: Optional[str] = None):
        """
        初始化 OCR 服务

        Args:
            tesseract_path: Tesseract 可执行文件路径(Windows 需要)
        """
        if tesseract_path:
            pytesseract.pytesseract.tesseract_cmd = tesseract_path

        self.languages = 'chi_sim+eng'  # 中文简体 + 英文
        self.min_confidence = 60.0  # 最低置信度阈值

        # 验证 Tesseract 安装
        self._verify_installation()

    def _verify_installation(self):
        """验证 Tesseract 安装和语言包"""
        try:
            version = pytesseract.get_tesseract_version()
            logger.info(f"Tesseract version: {version}")

            # 检查语言包
            available_langs = pytesseract.get_languages()
            required_langs = ['chi_sim', 'eng']

            for lang in required_langs:
                if lang not in available_langs:
                    logger.warning(f"Language pack '{lang}' not found")
                    raise RuntimeError(f"Missing Tesseract language pack: {lang}")

            logger.info(f"Available languages: {', '.join(available_langs)}")

        except Exception as e:
            logger.error(f"Tesseract verification failed: {e}")
            raise RuntimeError(
                "Tesseract OCR is not properly installed. "
                "Please install Tesseract and required language packs."
            )

    def preprocess_image(self, image: Image.Image) -> Image.Image:
        """
        图像预处理

        Args:
            image: PIL Image 对象

        Returns:
            处理后的 Image 对象
        """
        # 转换为 OpenCV 格式
        img_array = np.array(image)

        # 转为灰度图
        if len(img_array.shape) == 3:
            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
        else:
            gray = img_array

        # 应用 CLAHE(对比度限制自适应直方图均衡化)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        enhanced = clahe.apply(gray)

        # 去噪
        denoised = cv2.fastNlMeansDenoising(enhanced, h=10)

        # 自适应二值化
        binary = cv2.adaptiveThreshold(
            denoised,
            255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY,
            11,
            2
        )

        # 转回 PIL Image
        processed_image = Image.fromarray(binary)

        return processed_image

    def recognize_text(
        self,
        image: Image.Image,
        preprocess: bool = True
    ) -> OCRResult:
        """
        识别图像中的文本

        Args:
            image: PIL Image 对象
            preprocess: 是否进行预处理

        Returns:
            OCRResult 对象
        """
        start_time = time.time()

        try:
            # 图像预处理
            if preprocess:
                image = self.preprocess_image(image)

            # OCR 配置
            config = f'--psm 3 --oem 3'  # PSM 3: 自动页面分割, OEM 3: 默认引擎

            # 执行 OCR
            data = pytesseract.image_to_data(
                image,
                lang=self.languages,
                config=config,
                output_type=pytesseract.Output.DICT
            )

            # 提取文本和置信度
            text_parts = []
            confidences = []

            for i, conf in enumerate(data['conf']):
                if conf > 0:  # 有效识别
                    text = data['text'][i].strip()
                    if text:
                        # 置信度过滤
                        if conf >= self.min_confidence:
                            text_parts.append(text)
                            confidences.append(conf)

            # 组合文本
            full_text = ' '.join(text_parts)

            # 计算平均置信度
            avg_confidence = sum(confidences) / len(confidences) if confidences else 0.0

            processing_time = time.time() - start_time

            logger.info(
                f"OCR completed: {len(full_text)} chars, "
                f"confidence={avg_confidence:.2f}%, "
                f"time={processing_time:.2f}s"
            )

            return OCRResult(
                text=full_text,
                confidence=avg_confidence,
                language=self.languages,
                processing_time=processing_time,
                success=True
            )

        except Exception as e:
            logger.error(f"OCR recognition failed: {e}")
            return OCRResult(
                text='',
                confidence=0.0,
                language=self.languages,
                processing_time=time.time() - start_time,
                success=False,
                error=str(e)
            )

    def recognize_pdf_page(
        self,
        pdf_page,
        dpi: int = 300
    ) -> OCRResult:
        """
        识别 PDF 页面

        Args:
            pdf_page: pdfplumber page 对象
            dpi: 图像 DPI

        Returns:
            OCRResult 对象
        """
        try:
            # 将 PDF 页面转为图像
            image = pdf_page.to_image(resolution=dpi).original

            # 执行 OCR
            return self.recognize_text(image, preprocess=True)

        except Exception as e:
            logger.error(f"PDF page OCR failed: {e}")
            return OCRResult(
                text='',
                confidence=0.0,
                language=self.languages,
                processing_time=0.0,
                success=False,
                error=str(e)
            )
```

### PDF 类型检测

```python
# src/parsers/pdf_parser.py (扩展)
import pdfplumber
import logging
from typing import Tuple

logger = logging.getLogger(__name__)

class PdfParser:
    """PDF 解析器(支持 OCR)"""

    @staticmethod
    def detect_pdf_type(pdf_path: str) -> Tuple[str, dict]:
        """
        检测 PDF 类型

        Returns:
            ('text' | 'scanned' | 'mixed', metadata)
        """
        try:
            with pdfplumber.open(pdf_path) as pdf:
                total_pages = len(pdf.pages)
                text_pages = 0
                image_pages = 0
                total_chars = 0

                # 采样检测(最多检测前 10 页)
                sample_size = min(10, total_pages)

                for i in range(sample_size):
                    page = pdf.pages[i]

                    # 提取文本
                    text = page.extract_text() or ''
                    chars = len(text.strip())
                    total_chars += chars

                    # 检测图像
                    images = page.images

                    # 判断页面类型
                    if chars > 100:  # 有足够的文本
                        text_pages += 1
                    elif images:  # 有图像但文本很少
                        image_pages += 1

                # 计算比例
                text_ratio = text_pages / sample_size
                image_ratio = image_pages / sample_size
                avg_chars = total_chars / sample_size

                # 分类逻辑
                if text_ratio > 0.8:
                    pdf_type = 'text'
                elif image_ratio > 0.6 or avg_chars < 50:
                    pdf_type = 'scanned'
                else:
                    pdf_type = 'mixed'

                metadata = {
                    'total_pages': total_pages,
                    'text_pages': text_pages,
                    'image_pages': image_pages,
                    'avg_chars_per_page': avg_chars,
                    'text_ratio': text_ratio,
                    'image_ratio': image_ratio
                }

                logger.info(
                    f"PDF type detected: {pdf_type}, "
                    f"pages={total_pages}, "
                    f"text_ratio={text_ratio:.2f}, "
                    f"avg_chars={avg_chars:.0f}"
                )

                return pdf_type, metadata

        except Exception as e:
            logger.error(f"PDF type detection failed: {e}")
            return 'unknown', {}

    def parse_with_ocr(self, file_path: str, ocr_service: OCRService) -> ParseResult:
        """
        解析 PDF (支持 OCR)

        Args:
            file_path: PDF 文件路径
            ocr_service: OCR 服务实例

        Returns:
            ParseResult 对象
        """
        start_time = time.time()

        try:
            # 检测 PDF 类型
            pdf_type, type_metadata = self.detect_pdf_type(file_path)

            with pdfplumber.open(file_path) as pdf:
                content_parts = []
                ocr_pages = 0
                total_confidence = 0.0

                for i, page in enumerate(pdf.pages):
                    # 先尝试提取文本
                    text = page.extract_text() or ''

                    # 如果文本很少,使用 OCR
                    if len(text.strip()) < 50:
                        logger.info(f"Using OCR for page {i+1}")
                        ocr_result = ocr_service.recognize_pdf_page(page)

                        if ocr_result.success:
                            content_parts.append(ocr_result.text)
                            ocr_pages += 1
                            total_confidence += ocr_result.confidence
                        else:
                            logger.warning(f"OCR failed for page {i+1}")
                    else:
                        content_parts.append(text)

                content = '\n\n'.join(content_parts)

                # 计算 OCR 平均置信度
                avg_confidence = (
                    total_confidence / ocr_pages if ocr_pages > 0 else 0.0
                )

                metadata = {
                    'pages': len(pdf.pages),
                    'pdf_type': pdf_type,
                    'ocr_pages': ocr_pages,
                    'ocr_confidence': avg_confidence,
                    **type_metadata
                }

                return ParseResult(
                    success=True,
                    content=content,
                    metadata=metadata,
                    parse_time=time.time() - start_time
                )

        except Exception as e:
            logger.error(f"Failed to parse PDF with OCR: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )
```

### OCR 缓存

```python
# src/services/ocr_cache.py
import hashlib
import json
import os
from typing import Optional
from pathlib import Path

class OCRCache:
    """OCR 结果缓存"""

    def __init__(self, cache_dir: str = '.cache/ocr'):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def _get_cache_key(self, file_path: str, page_num: int = 0) -> str:
        """生成缓存键"""
        # 使用文件路径 + 修改时间 + 页码生成唯一键
        stat = os.stat(file_path)
        key_string = f"{file_path}:{stat.st_mtime}:{page_num}"
        return hashlib.md5(key_string.encode()).hexdigest()

    def get(self, file_path: str, page_num: int = 0) -> Optional[str]:
        """获取缓存的 OCR 结果"""
        cache_key = self._get_cache_key(file_path, page_num)
        cache_file = self.cache_dir / f"{cache_key}.json"

        if cache_file.exists():
            with open(cache_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data.get('text')

        return None

    def set(self, file_path: str, text: str, page_num: int = 0):
        """保存 OCR 结果到缓存"""
        cache_key = self._get_cache_key(file_path, page_num)
        cache_file = self.cache_dir / f"{cache_key}.json"

        with open(cache_file, 'w', encoding='utf-8') as f:
            json.dump({'text': text, 'page_num': page_num}, f, ensure_ascii=False)
```

## Dependencies

**外部依赖:**
- pytesseract 0.3+
- Tesseract OCR 引擎(系统安装)
- Pillow 10.0+
- opencv-python 4.8+
- numpy 1.24+
- pdf2image 1.16+ (可选)

**Tesseract 语言包:**
- chi_sim (简体中文)
- eng (英文)

**内部依赖:**
- Task 002: 文档解析引擎(PdfParser)

## Effort Estimate

- **Size:** M (Medium)
- **Hours:** 12-16 小时
- **Parallel:** true (可与其他任务并行)

**时间分配:**
- OCRService 类实现: 4 小时
- 图像预处理管道: 3 小时
- PDF 类型检测和集成: 3 小时
- OCR 缓存实现: 2 小时
- 单元测试和调优: 4 小时

## Definition of Done

- [x] 代码实现完成
  - OCRService 类实现
  - 图像预处理管道
  - PDF 类型检测
  - OCR 缓存机制
  - PdfParser OCR 集成

- [x] 测试完成
  - PDF 类型检测准确性测试
  - OCR 准确率测试(中英文)
  - 性能测试(大文件处理)
  - 缓存功能测试
  - 代码覆盖率 ≥ 85%

- [x] 文档完成
  - OCR 使用文档
  - Tesseract 安装指南
  - 配置说明
  - API 文档

- [x] 代码质量
  - 通过 black 格式化
  - 通过 pylint 检查(评分 ≥ 8.0)
  - 类型注解完整

- [x] 验收测试
  - 能正确识别扫描型 PDF
  - 中英文混合识别准确
  - OCR 结果置信度合理
  - 缓存机制正常工作
  - 性能满足要求(单页 OCR < 10 秒)

## Notes

**Tesseract 安装:**
- Windows: 下载安装包,配置环境变量
- macOS: `brew install tesseract tesseract-lang`
- Linux: `apt-get install tesseract-ocr tesseract-ocr-chi-sim`

**性能优化建议:**
- 大 PDF 文件分批处理
- 使用多进程并行 OCR
- 合理设置图像 DPI(推荐 300)
- 充分利用缓存机制

**已知限制:**
- OCR 准确率受图像质量影响
- 复杂排版可能识别错误
- 手写字体识别效果差
- 处理速度较慢(扫描版 PDF)
