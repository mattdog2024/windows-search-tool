---
name: PyQt6 搜索界面实现
status: open
created: 2025-10-16T08:21:20Z
updated: 2025-10-16T08:21:20Z
github: https://github.com/mattdog2024/windows-search-tool/issues/8
depends_on: [005, 006]
parallel: false
conflicts_with: []
---

# Task: PyQt6 搜索界面实现

## Description

实现 Windows Search Tool 的搜索界面,包括搜索输入框、模式选择、结果列表展示、文档内容查看器和分页加载功能。这是用户与搜索引擎交互的核心界面,需要提供流畅的搜索体验和清晰的结果展示。

**核心目标:**
- 实现 SearchPanel 搜索面板主框架
- 实现搜索输入框和实时搜索
- 实现搜索结果列表(QTableView + 自定义模型)
- 实现文档内容查看器(QTextBrowser + HTML 高亮)
- 实现结果分页加载和无限滚动
- 实现搜索历史和快速过滤

## Acceptance Criteria

- [ ] 搜索面板框架实现
  - **SearchPanel (QWidget)**
    - 顶部: 搜索栏(输入框 + 搜索按钮 + 模式切换)
    - 中部: 结果列表(QTableView)
    - 底部: 文档预览(QTextBrowser)
    - 分割器调整预览区域大小
    - 搜索状态显示(搜索中、结果数量、耗时)

- [ ] 搜索输入框实现
  - **SearchBar (QWidget)**
    - 搜索输入框(QLineEdit)
    - 搜索按钮(Enter 快捷键)
    - 清除按钮(X 图标)
    - 搜索历史下拉(QCompleter)
    - 实时搜索(输入延迟 500ms)
    - 搜索模式切换(全文/前缀/精确)
    - 高级选项(文件类型过滤、时间范围)

- [ ] 搜索结果列表实现
  - **SearchResultTable (QTableView)**
    - 列: 文件名、路径、类型、大小、修改时间、相关度
    - 自定义数据模型(SearchResultModel)
    - 排序功能(按相关度、时间、大小)
    - 行高亮(选中行)
    - 双击打开文件
    - 右键菜单(打开、打开位置、复制路径)
    - 虚拟滚动(支持大量结果)

- [ ] 搜索结果模型实现
  - **SearchResultModel (QAbstractTableModel)**
    - 数据存储和管理
    - 分页加载支持
    - 动态添加数据(append_results)
    - 列数据提供(data 方法)
    - 排序支持(sort 方法)

- [ ] 文档预览器实现
  - **DocumentViewer (QTextBrowser)**
    - 显示文档内容(HTML 格式)
    - 搜索词高亮显示(<mark> 标签)
    - 支持滚动和缩放
    - 显示文档元数据(标题、作者、创建时间)
    - 加载状态显示(加载中、加载失败)
    - 支持代码高亮(Markdown, CSV)

- [ ] 分页加载实现
  - **PaginationWidget (QWidget)**
    - 页码显示(1 / 10)
    - 上一页/下一页按钮
    - 跳转到页(输入框 + 跳转按钮)
    - 每页结果数选择(20/50/100)
    - 无限滚动模式(滚动到底部自动加载)

- [ ] 搜索历史管理
  - **SearchHistory 类**
    - 保存搜索历史(最多 100 条)
    - 持久化存储(JSON 文件)
    - 提供历史列表
    - 清除历史功能
    - 搜索建议(基于历史)

- [ ] 高级搜索选项
  - **AdvancedSearchDialog (QDialog)**
    - 文件类型过滤(多选)
    - 文件大小范围
    - 修改时间范围
    - 包含/排除路径
    - 正则表达式模式

## Technical Details

### SearchPanel 搜索面板

```python
# src/ui/search_panel.py
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QSplitter, QLabel
)
from PyQt6.QtCore import Qt, pyqtSignal, QTimer
import logging

from .search_bar import SearchBar
from .search_result_table import SearchResultTable
from .document_viewer import DocumentViewer
from .pagination_widget import PaginationWidget
from ..core.search_service import SearchService

logger = logging.getLogger(__name__)

class SearchPanel(QWidget):
    """搜索面板"""

    def __init__(self):
        super().__init__()
        self.search_service = SearchService()
        self.current_index_id = None
        self.current_page = 1
        self.results_per_page = 20
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # 搜索栏
        self.search_bar = SearchBar()
        self.search_bar.search_requested.connect(self.on_search)
        self.search_bar.clear_requested.connect(self.on_clear)
        layout.addWidget(self.search_bar)

        # 状态标签
        self.status_label = QLabel("输入关键词开始搜索")
        layout.addWidget(self.status_label)

        # 分割器(结果列表 + 预览)
        splitter = QSplitter(Qt.Orientation.Vertical)

        # 结果列表
        self.result_table = SearchResultTable()
        self.result_table.row_selected.connect(self.on_result_selected)
        splitter.addWidget(self.result_table)

        # 文档预览
        self.document_viewer = DocumentViewer()
        splitter.addWidget(self.document_viewer)

        # 设置分割比例 (60% : 40%)
        splitter.setSizes([600, 400])

        layout.addWidget(splitter)

        # 分页控件
        self.pagination = PaginationWidget()
        self.pagination.page_changed.connect(self.on_page_changed)
        layout.addWidget(self.pagination)

    def set_index(self, index_id: int):
        """设置当前索引"""
        self.current_index_id = index_id
        self.on_clear()

    def on_search(self, query: str, mode: str):
        """执行搜索"""
        if not self.current_index_id:
            self.status_label.setText("请先选择索引")
            return

        if not query.strip():
            return

        try:
            self.status_label.setText("搜索中...")

            # 执行搜索
            import time
            start_time = time.time()

            results = self.search_service.search(
                index_id=self.current_index_id,
                query=query,
                mode=mode,
                limit=self.results_per_page,
                offset=(self.current_page - 1) * self.results_per_page
            )

            elapsed = time.time() - start_time

            # 更新结果列表
            self.result_table.set_results(results['items'])

            # 更新分页
            total_pages = (results['total'] + self.results_per_page - 1) // self.results_per_page
            self.pagination.set_total_pages(total_pages)

            # 更新状态
            self.status_label.setText(
                f"找到 {results['total']} 个结果 (耗时 {elapsed:.2f} 秒)"
            )

        except Exception as e:
            logger.error(f"Search failed: {e}")
            self.status_label.setText(f"搜索失败: {e}")

    def on_clear(self):
        """清除搜索结果"""
        self.result_table.clear()
        self.document_viewer.clear()
        self.pagination.reset()
        self.status_label.setText("输入关键词开始搜索")

    def on_result_selected(self, result: dict):
        """结果选中事件"""
        # 加载文档预览
        self.document_viewer.load_document(result['document_id'], result['snippet'])

    def on_page_changed(self, page: int):
        """页面切换事件"""
        self.current_page = page
        query = self.search_bar.get_query()
        mode = self.search_bar.get_mode()
        if query:
            self.on_search(query, mode)
```

### SearchBar 搜索栏

```python
# src/ui/search_bar.py
from PyQt6.QtWidgets import (
    QWidget, QHBoxLayout, QLineEdit, QPushButton,
    QComboBox, QCompleter
)
from PyQt6.QtCore import Qt, pyqtSignal, QTimer
from PyQt6.QtGui import QKeyEvent
import logging

from .search_history import SearchHistory

logger = logging.getLogger(__name__)

class SearchBar(QWidget):
    """搜索栏"""

    search_requested = pyqtSignal(str, str)  # (query, mode)
    clear_requested = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.search_history = SearchHistory()
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._do_search)
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        layout = QHBoxLayout(self)

        # 搜索输入框
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("输入搜索关键词...")
        self.search_input.returnPressed.connect(self._do_search)
        self.search_input.textChanged.connect(self.on_text_changed)

        # 设置自动完成
        completer = QCompleter(self.search_history.get_history())
        completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.search_input.setCompleter(completer)

        layout.addWidget(self.search_input)

        # 清除按钮
        self.clear_button = QPushButton("×")
        self.clear_button.setMaximumWidth(30)
        self.clear_button.clicked.connect(self.on_clear)
        layout.addWidget(self.clear_button)

        # 搜索模式选择
        self.mode_combo = QComboBox()
        self.mode_combo.addItems(["全文搜索", "前缀匹配", "精确匹配"])
        self.mode_combo.setCurrentIndex(0)
        layout.addWidget(self.mode_combo)

        # 搜索按钮
        self.search_button = QPushButton("搜索")
        self.search_button.clicked.connect(self._do_search)
        layout.addWidget(self.search_button)

        # 高级选项按钮
        self.advanced_button = QPushButton("高级")
        self.advanced_button.clicked.connect(self.on_advanced)
        layout.addWidget(self.advanced_button)

    def on_text_changed(self, text: str):
        """文本变化事件(实时搜索)"""
        # 延迟 500ms 后搜索
        self.search_timer.stop()
        if text.strip():
            self.search_timer.start(500)

    def _do_search(self):
        """执行搜索"""
        query = self.search_input.text().strip()
        if query:
            # 保存到历史
            self.search_history.add(query)

            # 更新自动完成
            completer = QCompleter(self.search_history.get_history())
            completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
            self.search_input.setCompleter(completer)

            # 发送搜索信号
            mode = self._get_mode_value()
            self.search_requested.emit(query, mode)

    def on_clear(self):
        """清除输入"""
        self.search_input.clear()
        self.clear_requested.emit()

    def on_advanced(self):
        """打开高级搜索"""
        from .advanced_search_dialog import AdvancedSearchDialog
        dialog = AdvancedSearchDialog(self)
        if dialog.exec() == 1:
            filters = dialog.get_filters()
            # TODO: 应用高级过滤器

    def get_query(self) -> str:
        """获取查询文本"""
        return self.search_input.text().strip()

    def get_mode(self) -> str:
        """获取搜索模式"""
        return self._get_mode_value()

    def _get_mode_value(self) -> str:
        """获取模式值"""
        mode_index = self.mode_combo.currentIndex()
        modes = ['fulltext', 'prefix', 'exact']
        return modes[mode_index]
```

### SearchResultTable 结果列表

```python
# src/ui/search_result_table.py
from PyQt6.QtWidgets import QTableView, QHeaderView, QMenu
from PyQt6.QtCore import Qt, pyqtSignal, QAbstractTableModel, QModelIndex
from PyQt6.QtGui import QAction
import logging
import os
import subprocess

logger = logging.getLogger(__name__)

class SearchResultModel(QAbstractTableModel):
    """搜索结果数据模型"""

    def __init__(self):
        super().__init__()
        self.results = []
        self.headers = ["文件名", "路径", "类型", "大小", "修改时间", "相关度"]

    def rowCount(self, parent=QModelIndex()):
        return len(self.results)

    def columnCount(self, parent=QModelIndex()):
        return len(self.headers)

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        result = self.results[index.row()]
        col = index.column()

        if role == Qt.ItemDataRole.DisplayRole:
            if col == 0:
                return result['file_name']
            elif col == 1:
                return result['file_path']
            elif col == 2:
                return result['file_type']
            elif col == 3:
                return self._format_size(result['file_size'])
            elif col == 4:
                return result['modified_at']
            elif col == 5:
                return f"{result.get('rank', 0):.2f}"

        elif role == Qt.ItemDataRole.UserRole:
            return result

        return None

    def headerData(self, section, orientation, role=Qt.ItemDataRole.DisplayRole):
        if orientation == Qt.Orientation.Horizontal and role == Qt.ItemDataRole.DisplayRole:
            return self.headers[section]
        return None

    def set_results(self, results: list):
        """设置结果"""
        self.beginResetModel()
        self.results = results
        self.endResetModel()

    def append_results(self, results: list):
        """追加结果"""
        start_row = len(self.results)
        end_row = start_row + len(results) - 1
        self.beginInsertRows(QModelIndex(), start_row, end_row)
        self.results.extend(results)
        self.endInsertRows()

    def clear(self):
        """清除结果"""
        self.beginResetModel()
        self.results = []
        self.endResetModel()

    @staticmethod
    def _format_size(size: int) -> str:
        """格式化文件大小"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.2f} {unit}"
            size /= 1024
        return f"{size:.2f} PB"


class SearchResultTable(QTableView):
    """搜索结果表格"""

    row_selected = pyqtSignal(dict)  # 选中行信号

    def __init__(self):
        super().__init__()
        self.model = SearchResultModel()
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        self.setModel(self.model)

        # 表格设置
        self.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.setSelectionMode(QTableView.SelectionMode.SingleSelection)
        self.setAlternatingRowColors(True)
        self.setSortingEnabled(True)

        # 列宽设置
        header = self.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(5, QHeaderView.ResizeMode.ResizeToContents)

        # 连接信号
        self.clicked.connect(self.on_row_clicked)
        self.doubleClicked.connect(self.on_row_double_clicked)

        # 右键菜单
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def set_results(self, results: list):
        """设置结果"""
        self.model.set_results(results)

    def append_results(self, results: list):
        """追加结果"""
        self.model.append_results(results)

    def clear(self):
        """清除结果"""
        self.model.clear()

    def on_row_clicked(self, index: QModelIndex):
        """行点击事件"""
        result = self.model.data(index, Qt.ItemDataRole.UserRole)
        if result:
            self.row_selected.emit(result)

    def on_row_double_clicked(self, index: QModelIndex):
        """行双击事件"""
        result = self.model.data(index, Qt.ItemDataRole.UserRole)
        if result:
            self.open_file(result['file_path'])

    def show_context_menu(self, position):
        """显示右键菜单"""
        index = self.indexAt(position)
        if not index.isValid():
            return

        result = self.model.data(index, Qt.ItemDataRole.UserRole)

        menu = QMenu()

        open_action = QAction("打开文件", self)
        open_action.triggered.connect(lambda: self.open_file(result['file_path']))
        menu.addAction(open_action)

        open_location_action = QAction("打开文件位置", self)
        open_location_action.triggered.connect(lambda: self.open_location(result['file_path']))
        menu.addAction(open_location_action)

        menu.addSeparator()

        copy_path_action = QAction("复制路径", self)
        copy_path_action.triggered.connect(lambda: self.copy_path(result['file_path']))
        menu.addAction(copy_path_action)

        menu.exec(self.viewport().mapToGlobal(position))

    def open_file(self, file_path: str):
        """打开文件"""
        try:
            os.startfile(file_path)
        except Exception as e:
            logger.error(f"Failed to open file: {e}")

    def open_location(self, file_path: str):
        """打开文件位置"""
        try:
            subprocess.Popen(f'explorer /select,"{file_path}"')
        except Exception as e:
            logger.error(f"Failed to open location: {e}")

    def copy_path(self, file_path: str):
        """复制路径到剪贴板"""
        from PyQt6.QtWidgets import QApplication
        clipboard = QApplication.clipboard()
        clipboard.setText(file_path)
```

### DocumentViewer 文档预览

```python
# src/ui/document_viewer.py
from PyQt6.QtWidgets import QTextBrowser, QVBoxLayout, QWidget, QLabel
from PyQt6.QtCore import Qt
import logging

from ..core.search_service import SearchService

logger = logging.getLogger(__name__)

class DocumentViewer(QWidget):
    """文档查看器"""

    def __init__(self):
        super().__init__()
        self.search_service = SearchService()
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # 标题栏
        self.title_label = QLabel("文档预览")
        layout.addWidget(self.title_label)

        # 文本浏览器
        self.text_browser = QTextBrowser()
        self.text_browser.setOpenExternalLinks(False)
        layout.addWidget(self.text_browser)

    def load_document(self, document_id: int, snippet: str):
        """加载文档"""
        try:
            self.title_label.setText("加载中...")

            # 获取文档详情
            document = self.search_service.get_document(document_id)

            # 构建 HTML 内容
            html = self._build_html(document, snippet)

            # 显示内容
            self.text_browser.setHtml(html)
            self.title_label.setText(f"文档预览: {document['file_name']}")

        except Exception as e:
            logger.error(f"Failed to load document: {e}")
            self.text_browser.setHtml(f"<p style='color: red;'>加载失败: {e}</p>")
            self.title_label.setText("加载失败")

    def clear(self):
        """清除内容"""
        self.text_browser.clear()
        self.title_label.setText("文档预览")

    def _build_html(self, document: dict, snippet: str) -> str:
        """构建 HTML 内容"""
        metadata = document.get('metadata', {})

        html = f"""
        <html>
        <head>
            <style>
                body {{ font-family: 'Microsoft YaHei', Arial, sans-serif; padding: 10px; }}
                .metadata {{ background-color: #f5f5f5; padding: 10px; margin-bottom: 10px; border-radius: 5px; }}
                .metadata-item {{ margin: 5px 0; }}
                .label {{ font-weight: bold; color: #555; }}
                .content {{ white-space: pre-wrap; line-height: 1.6; }}
                mark {{ background-color: yellow; font-weight: bold; }}
            </style>
        </head>
        <body>
            <div class="metadata">
                <div class="metadata-item"><span class="label">文件名:</span> {document['file_name']}</div>
                <div class="metadata-item"><span class="label">路径:</span> {document['file_path']}</div>
                <div class="metadata-item"><span class="label">大小:</span> {self._format_size(document['file_size'])}</div>
                <div class="metadata-item"><span class="label">修改时间:</span> {document['modified_at']}</div>
                {self._format_metadata(metadata)}
            </div>
            <div class="content">
                <h4>相关内容片段:</h4>
                {snippet}
            </div>
        </body>
        </html>
        """
        return html

    def _format_metadata(self, metadata: dict) -> str:
        """格式化元数据"""
        html = ""
        for key, value in metadata.items():
            html += f'<div class="metadata-item"><span class="label">{key}:</span> {value}</div>'
        return html

    @staticmethod
    def _format_size(size: int) -> str:
        """格式化文件大小"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.2f} {unit}"
            size /= 1024
        return f"{size:.2f} PB"
```

### PaginationWidget 分页控件

```python
# src/ui/pagination_widget.py
from PyQt6.QtWidgets import (
    QWidget, QHBoxLayout, QPushButton, QLabel,
    QLineEdit, QComboBox
)
from PyQt6.QtCore import pyqtSignal
import logging

logger = logging.getLogger(__name__)

class PaginationWidget(QWidget):
    """分页控件"""

    page_changed = pyqtSignal(int)  # 页面变化信号

    def __init__(self):
        super().__init__()
        self.current_page = 1
        self.total_pages = 1
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        layout = QHBoxLayout(self)

        # 上一页按钮
        self.prev_button = QPushButton("上一页")
        self.prev_button.clicked.connect(self.on_prev)
        layout.addWidget(self.prev_button)

        # 页码显示
        self.page_label = QLabel("1 / 1")
        layout.addWidget(self.page_label)

        # 下一页按钮
        self.next_button = QPushButton("下一页")
        self.next_button.clicked.connect(self.on_next)
        layout.addWidget(self.next_button)

        layout.addStretch()

        # 跳转到页
        self.jump_label = QLabel("跳转到:")
        layout.addWidget(self.jump_label)

        self.jump_input = QLineEdit()
        self.jump_input.setMaximumWidth(50)
        self.jump_input.returnPressed.connect(self.on_jump)
        layout.addWidget(self.jump_input)

        self.jump_button = QPushButton("Go")
        self.jump_button.clicked.connect(self.on_jump)
        layout.addWidget(self.jump_button)

        # 每页结果数
        self.per_page_label = QLabel("每页:")
        layout.addWidget(self.per_page_label)

        self.per_page_combo = QComboBox()
        self.per_page_combo.addItems(["20", "50", "100"])
        self.per_page_combo.setCurrentIndex(0)
        layout.addWidget(self.per_page_combo)

        self.update_buttons()

    def set_total_pages(self, total: int):
        """设置总页数"""
        self.total_pages = max(1, total)
        self.current_page = 1
        self.update_ui()

    def reset(self):
        """重置"""
        self.current_page = 1
        self.total_pages = 1
        self.update_ui()

    def on_prev(self):
        """上一页"""
        if self.current_page > 1:
            self.current_page -= 1
            self.update_ui()
            self.page_changed.emit(self.current_page)

    def on_next(self):
        """下一页"""
        if self.current_page < self.total_pages:
            self.current_page += 1
            self.update_ui()
            self.page_changed.emit(self.current_page)

    def on_jump(self):
        """跳转到页"""
        try:
            page = int(self.jump_input.text())
            if 1 <= page <= self.total_pages:
                self.current_page = page
                self.update_ui()
                self.page_changed.emit(self.current_page)
            else:
                self.jump_input.clear()
        except ValueError:
            self.jump_input.clear()

    def update_ui(self):
        """更新界面"""
        self.page_label.setText(f"{self.current_page} / {self.total_pages}")
        self.update_buttons()

    def update_buttons(self):
        """更新按钮状态"""
        self.prev_button.setEnabled(self.current_page > 1)
        self.next_button.setEnabled(self.current_page < self.total_pages)
```

### SearchHistory 搜索历史

```python
# src/ui/search_history.py
import json
import os
from pathlib import Path
from typing import List
import logging

logger = logging.getLogger(__name__)

class SearchHistory:
    """搜索历史管理"""

    MAX_HISTORY = 100

    def __init__(self):
        self.history_file = Path(os.getenv('APPDATA')) / 'WindowsSearchTool' / 'search_history.json'
        self.history = self._load_history()

    def _load_history(self) -> List[str]:
        """加载历史"""
        if self.history_file.exists():
            try:
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load search history: {e}")
        return []

    def _save_history(self):
        """保存历史"""
        try:
            self.history_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(self.history, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Failed to save search history: {e}")

    def add(self, query: str):
        """添加搜索历史"""
        # 移除重复项
        if query in self.history:
            self.history.remove(query)

        # 添加到开头
        self.history.insert(0, query)

        # 限制数量
        if len(self.history) > self.MAX_HISTORY:
            self.history = self.history[:self.MAX_HISTORY]

        # 保存
        self._save_history()

    def get_history(self) -> List[str]:
        """获取历史列表"""
        return self.history.copy()

    def clear(self):
        """清除历史"""
        self.history = []
        self._save_history()
```

## Dependencies

**外部依赖:**
- PyQt6 6.5+

**内部依赖:**
- Task 005: 搜索引擎实现
- Task 006: 主窗口和索引管理界面
- Task 001: 项目基础架构(配置管理、日志系统)

## Effort Estimate

- **Size:** M (Medium)
- **Hours:** 14-18 小时
- **Parallel:** false (依赖 Task 005 和 Task 006)

**时间分配:**
- SearchPanel 框架: 2 小时
- SearchBar 实现: 3 小时
- SearchResultTable 实现: 4 小时
- DocumentViewer 实现: 3 小时
- PaginationWidget 实现: 2 小时
- SearchHistory 实现: 1 小时
- 测试和调试: 3 小时
- UI 优化和文档: 2 小时

## Definition of Done

- [x] 代码实现完成
  - SearchPanel 主框架
  - SearchBar 搜索栏
  - SearchResultTable 结果列表
  - DocumentViewer 文档预览
  - PaginationWidget 分页控件
  - SearchHistory 历史管理

- [x] 功能测试完成
  - 搜索功能正常工作
  - 结果正确展示
  - 文档预览正确显示
  - 分页功能正常
  - 搜索历史保存和加载

- [x] UI/UX 测试完成
  - 搜索响应流畅(< 500ms)
  - 结果列表虚拟滚动流畅
  - 高亮显示清晰可见
  - 分页操作直观
  - 右键菜单功能完整

- [x] 代码质量
  - 通过 black 格式化
  - 通过 pylint 检查(评分 ≥ 8.0)
  - 类型注解完整
  - 信号和槽连接正确

- [x] 验收测试
  - 能执行全文搜索并显示结果
  - 搜索词在结果中正确高亮
  - 文档预览显示完整信息
  - 分页切换正常
  - 搜索历史功能正常
