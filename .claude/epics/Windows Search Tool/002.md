---
name: 文档解析引擎实现
status: open
created: 2025-10-16T08:21:20Z
updated: 2025-10-16T08:21:20Z
github: Will be updated when synced to GitHub
depends_on: [001]
parallel: false
conflicts_with: []
---

# Task: 文档解析引擎实现

## Description

实现可扩展的文档解析框架,支持多种文档格式(Office, PDF, 文本文件)的内容提取。采用工厂模式设计,便于后续添加新格式支持。重点利用成熟的 Python 库(python-docx, openpyxl, python-pptx, pdfplumber)简化开发。

**核心目标:**
- 实现 IDocumentParser 抽象基类和 ParserFactory 工厂
- 实现 Office 文档解析器(docx, xlsx, pptx)
- 实现 PDF 解析器(pdfplumber,暂不包含 OCR)
- 实现文本文件解析器(.txt, .csv, .md)
- 实现统一的异常处理和日志记录

## Acceptance Criteria

- [ ] 解析器框架实现
  - IDocumentParser 抽象基类定义
  - ParserFactory 工厂类实现
  - ParseResult 数据类定义
  - 解析器注册机制

- [ ] Office 文档解析器实现
  - **DocxParser (Word 文档)**
    - 提取正文文本(段落)
    - 提取表格内容
    - 提取页眉和页脚
    - 提取文档元数据(作者、标题、创建时间等)
    - 正确处理中文和特殊字符

  - **XlsxParser (Excel 文档)**
    - 提取所有工作表内容
    - 提取单元格文本和数值
    - 提取单元格公式(转为文本)
    - 处理合并单元格
    - 提取工作簿属性

  - **PptxParser (PowerPoint 文档)**
    - 提取所有幻灯片标题
    - 提取幻灯片正文内容
    - 提取演讲者备注
    - 保持幻灯片顺序
    - 提取演示文稿属性

- [ ] PDF 解析器实现 (基础版)
  - 使用 pdfplumber 提取文本型 PDF 内容
  - 提取 PDF 元数据(页数、作者、标题等)
  - 处理多页 PDF
  - 检测 PDF 类型(文本型 vs 扫描型)
  - 注: OCR 功能将在 Task 8 中实现

- [ ] 文本文件解析器实现
  - **TextParser (.txt, .md, .csv)**
    - 自动检测文件编码(UTF-8, GBK, GB2312)
    - 正确处理 BOM 标记
    - CSV 文件表格化处理
    - Markdown 文件保留基本格式

- [ ] 异常处理和日志
  - 解析失败时返回 ParseResult(success=False)
  - 记录详细的错误日志
  - 不影响其他文件的解析
  - 超时保护机制(单个文件最多 30 秒)

- [ ] 单元测试
  - 每个解析器的正确性测试
  - 异常情况测试(损坏文件、空文件等)
  - 中文内容测试
  - 代码覆盖率 ≥ 90%

## Technical Details

### 解析器框架

```python
# src/parsers/base.py
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, Any, Optional
import time

@dataclass
class ParseResult:
    """解析结果"""
    success: bool
    content: str
    metadata: Dict[str, Any]
    error: Optional[str] = None
    parse_time: float = 0.0

class IDocumentParser(ABC):
    """文档解析器接口"""

    @abstractmethod
    def supports(self, file_path: str) -> bool:
        """判断是否支持该文件"""
        pass

    @abstractmethod
    def parse(self, file_path: str) -> ParseResult:
        """解析文档"""
        pass

    def get_metadata(self, file_path: str) -> Dict[str, Any]:
        """获取文档元数据(可选实现)"""
        return {}

# src/parsers/factory.py
from typing import Dict, List, Optional
from .base import IDocumentParser

class ParserFactory:
    """解析器工厂"""

    def __init__(self):
        self._parsers: Dict[str, IDocumentParser] = {}
        self._register_default_parsers()

    def _register_default_parsers(self):
        """注册默认解析器"""
        from .office_parsers import DocxParser, XlsxParser, PptxParser
        from .pdf_parser import PdfParser
        from .text_parser import TextParser

        self.register_parser(['.docx'], DocxParser())
        self.register_parser(['.xlsx', '.xls'], XlsxParser())
        self.register_parser(['.pptx', '.ppt'], PptxParser())
        self.register_parser(['.pdf'], PdfParser())
        self.register_parser(['.txt', '.md', '.csv'], TextParser())

    def register_parser(self, extensions: List[str], parser: IDocumentParser):
        """注册解析器"""
        for ext in extensions:
            self._parsers[ext.lower()] = parser

    def get_parser(self, file_path: str) -> Optional[IDocumentParser]:
        """根据文件扩展名获取解析器"""
        import os
        ext = os.path.splitext(file_path)[1].lower()
        return self._parsers.get(ext)

    def supports(self, file_path: str) -> bool:
        """检查文件是否支持解析"""
        return self.get_parser(file_path) is not None
```

### Office 文档解析器

```python
# src/parsers/office_parsers.py
from docx import Document
from openpyxl import load_workbook
from pptx import Presentation
import logging
import time
from .base import IDocumentParser, ParseResult

logger = logging.getLogger(__name__)

class DocxParser(IDocumentParser):
    """Word 文档解析器"""

    def supports(self, file_path: str) -> bool:
        return file_path.lower().endswith('.docx')

    def parse(self, file_path: str) -> ParseResult:
        start_time = time.time()
        try:
            doc = Document(file_path)

            # 提取正文
            content_parts = []
            for paragraph in doc.paragraphs:
                if paragraph.text.strip():
                    content_parts.append(paragraph.text)

            # 提取表格
            for table in doc.tables:
                for row in table.rows:
                    for cell in row.cells:
                        if cell.text.strip():
                            content_parts.append(cell.text)

            content = '\n'.join(content_parts)

            # 提取元数据
            core_props = doc.core_properties
            metadata = {
                'author': core_props.author or '',
                'title': core_props.title or '',
                'created': core_props.created.isoformat() if core_props.created else '',
                'modified': core_props.modified.isoformat() if core_props.modified else '',
                'paragraphs': len(doc.paragraphs),
                'tables': len(doc.tables)
            }

            return ParseResult(
                success=True,
                content=content,
                metadata=metadata,
                parse_time=time.time() - start_time
            )

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )

class XlsxParser(IDocumentParser):
    """Excel 文档解析器"""

    def supports(self, file_path: str) -> bool:
        return file_path.lower().endswith(('.xlsx', '.xls'))

    def parse(self, file_path: str) -> ParseResult:
        start_time = time.time()
        try:
            workbook = load_workbook(file_path, data_only=True)
            content_parts = []

            for sheet_name in workbook.sheetnames:
                sheet = workbook[sheet_name]
                content_parts.append(f"工作表: {sheet_name}")

                for row in sheet.iter_rows(values_only=True):
                    row_text = ' | '.join(str(cell) for cell in row if cell is not None)
                    if row_text.strip():
                        content_parts.append(row_text)

            content = '\n'.join(content_parts)

            metadata = {
                'sheets': len(workbook.sheetnames),
                'sheet_names': workbook.sheetnames
            }

            return ParseResult(
                success=True,
                content=content,
                metadata=metadata,
                parse_time=time.time() - start_time
            )

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )

class PptxParser(IDocumentParser):
    """PowerPoint 文档解析器"""

    def supports(self, file_path: str) -> bool:
        return file_path.lower().endswith(('.pptx', '.ppt'))

    def parse(self, file_path: str) -> ParseResult:
        start_time = time.time()
        try:
            prs = Presentation(file_path)
            content_parts = []

            for i, slide in enumerate(prs.slides, 1):
                content_parts.append(f"幻灯片 {i}:")

                for shape in slide.shapes:
                    if hasattr(shape, "text") and shape.text.strip():
                        content_parts.append(shape.text)

                # 提取备注
                if slide.has_notes_slide:
                    notes = slide.notes_slide.notes_text_frame.text
                    if notes.strip():
                        content_parts.append(f"备注: {notes}")

            content = '\n'.join(content_parts)

            metadata = {
                'slides': len(prs.slides)
            }

            return ParseResult(
                success=True,
                content=content,
                metadata=metadata,
                parse_time=time.time() - start_time
            )

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )
```

### PDF 解析器(基础版)

```python
# src/parsers/pdf_parser.py
import pdfplumber
import logging
import time
from .base import IDocumentParser, ParseResult

logger = logging.getLogger(__name__)

class PdfParser(IDocumentParser):
    """PDF 文档解析器(基础版,不包含 OCR)"""

    def supports(self, file_path: str) -> bool:
        return file_path.lower().endswith('.pdf')

    def parse(self, file_path: str) -> ParseResult:
        start_time = time.time()
        try:
            with pdfplumber.open(file_path) as pdf:
                # 提取文本
                text_parts = []
                for page in pdf.pages:
                    text = page.extract_text()
                    if text:
                        text_parts.append(text)

                content = '\n'.join(text_parts)

                # 检测是否为扫描版(文本很少)
                is_scanned = len(content.strip()) < 100

                # 提取元数据
                metadata = {
                    'pages': len(pdf.pages),
                    'author': pdf.metadata.get('Author', ''),
                    'title': pdf.metadata.get('Title', ''),
                    'created': pdf.metadata.get('CreationDate', ''),
                    'is_scanned': is_scanned
                }

                if is_scanned:
                    logger.warning(f"{file_path} appears to be scanned PDF, OCR needed")

                return ParseResult(
                    success=True,
                    content=content,
                    metadata=metadata,
                    parse_time=time.time() - start_time
                )

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )
```

### 文本文件解析器

```python
# src/parsers/text_parser.py
import chardet
import logging
import time
from .base import IDocumentParser, ParseResult

logger = logging.getLogger(__name__)

class TextParser(IDocumentParser):
    """文本文件解析器"""

    def supports(self, file_path: str) -> bool:
        return file_path.lower().endswith(('.txt', '.md', '.csv'))

    def parse(self, file_path: str) -> ParseResult:
        start_time = time.time()
        try:
            # 检测编码
            with open(file_path, 'rb') as f:
                raw_data = f.read()
                result = chardet.detect(raw_data)
                encoding = result['encoding'] or 'utf-8'

            # 读取内容
            with open(file_path, 'r', encoding=encoding) as f:
                content = f.read()

            metadata = {
                'encoding': encoding,
                'confidence': result['confidence'],
                'lines': len(content.split('\n'))
            }

            return ParseResult(
                success=True,
                content=content,
                metadata=metadata,
                parse_time=time.time() - start_time
            )

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return ParseResult(
                success=False,
                content='',
                metadata={},
                error=str(e),
                parse_time=time.time() - start_time
            )
```

## Dependencies

**外部依赖:**
- python-docx 1.1+
- openpyxl 3.1+
- python-pptx 0.6+
- pdfplumber 0.10+
- chardet 5.0+

**内部依赖:**
- Task 001: 项目基础架构(日志系统)

## Effort Estimate

- **Size:** L (Large)
- **Hours:** 16-20 小时
- **Parallel:** false (依赖 Task 001)

**时间分配:**
- 解析器框架设计: 3 小时
- Office 解析器实现: 6 小时
- PDF 解析器实现: 3 小时
- 文本解析器实现: 2 小时
- 单元测试编写: 4 小时
- 文档和调试: 2 小时

## Definition of Done

- [x] 代码实现完成
  - IDocumentParser 和 ParserFactory 实现
  - 所有 5 个解析器实现(Docx, Xlsx, Pptx, Pdf, Text)
  - 异常处理完善

- [x] 测试完成
  - 每个解析器有完整的单元测试
  - 使用真实文档测试(包含中文内容)
  - 异常情况测试通过
  - 代码覆盖率 ≥ 90%

- [x] 文档完成
  - 每个解析器有详细的 docstring
  - 使用示例代码

- [x] 代码质量
  - 通过 black 格式化
  - 通过 pylint 检查(评分 ≥ 8.0)
  - 类型注解完整

- [x] 验收测试
  - 能成功解析各种格式的真实文档
  - 中文内容正确提取
  - 元数据正确提取
  - 解析失败时正确返回错误信息
